import fs from 'node:fs'
import { GptPromptComment, HeaderMatch } from './regex';

import { GPTDocument } from './document';
import { Config } from './config';

import path from 'node:path'

/** @gpt */
export class File {
    source: string;
    fullpath: string;
    doclets: GPTDocument[];

    config: Config;

    /** @gpt */
    constructor(_config: Config, _source: string, isPath: boolean = true) {
        
        this.config = _config;

        this.fullpath = _source;

        this.doclets = [];
        
        if (!isPath) {
            this.source = _source;
            return;
        } 

        this.source = fs.readFileSync(_source, 'utf-8');
    }

    static HEADER = (config: Config) => {
        if (config.disableHeader) return '';
        return `/**\n`+

        ` * Do not modify this file ! \n`+
        ` * This file is read & written by GPT-3\n`+
        ` * \n * ${config.DEBUG ? 
            'You are in DEBUG mode, Doclet generation is disabled\n * '+
            `To enable GPT completion, set the DEBUG variable to false in the config`
            :
            `Every Doclet with an @autogenerated tag is from GPT-3`
        }\n */\n\n`;
    }

    /** @gpt */
    parseDocuments() {
        const doclets = this.source.matchAll(GptPromptComment);

        this.doclets = Array.from(doclets).map((doclet: RegExpMatchArray) => {
            return new GPTDocument(doclet, this.config.tab_size);
        })
    }

    /** @gpt */
    async gptDescribe(openai: any) {
        for (let i = 0; i < this.doclets.length; i++) {
            this.source = 
                await this.doclets[i].gptDescribe(
                    openai, this.source, this.config
                );
        }
    }

    /** @gpt */
    async writeDir(dest_path: string = this.fullpath) {
        let dir = path.dirname(dest_path);

        if (!fs.existsSync(dir)) 
            await fs.promises.mkdir(dir);

        return await this.writeFile(dest_path);
    }

    /** @gpt */
    async writeFile(path: string) {
        const content = (
            this.source.match(HeaderMatch) === null &&
            !this.config.disableHeader
        ) ? File.HEADER(this.config) : '';

        await fs.promises.writeFile(
            path,
            content + this.source,
            'utf-8'
        )
    }

}